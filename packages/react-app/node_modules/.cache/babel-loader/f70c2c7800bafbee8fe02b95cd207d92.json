{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mymac/Documents/GitHub/Cryptoapp/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"/Users/mymac/Documents/GitHub/Cryptoapp/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/Users/mymac/Documents/GitHub/Cryptoapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/mymac/Documents/GitHub/Cryptoapp/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function connectContractToSigner(contract, options, librarySigner) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer);\n  }\n\n  if (librarySigner) {\n    return contract.connect(librarySigner);\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\n\nexport function useContractFunction(contract, functionName, options) {\n  var _a, _b, _c;\n\n  var _useEthers = useEthers(),\n      library = _useEthers.library,\n      chainId = _useEthers.chainId;\n\n  var transactionChainId = options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId) || chainId;\n\n  var _usePromiseTransactio = usePromiseTransaction(transactionChainId, options),\n      promiseTransaction = _usePromiseTransactio.promiseTransaction,\n      state = _usePromiseTransactio.state,\n      resetState = _usePromiseTransactio.resetState;\n\n  var _useState = useState(undefined),\n      _useState2 = _slicedToArray(_useState, 2),\n      events = _useState2[0],\n      setEvents = _useState2[1];\n\n  var config = useConfig();\n  var gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n  var providers = useReadonlyNetworks();\n  var provider = transactionChainId && providers[transactionChainId];\n  var send = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _a,\n        _b,\n        _len,\n        args,\n        _key,\n        hasOpts,\n        signer,\n        contractWithSigner,\n        opts,\n        gasLimit,\n        modifiedOpts,\n        modifiedArgs,\n        receipt,\n        _events,\n        _args = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!contract) {\n              _context.next = 17;\n              break;\n            }\n\n            for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = _args[_key];\n            }\n\n            hasOpts = args.length > ((_b = (_a = contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(functionName).inputs.length) !== null && _b !== void 0 ? _b : 0);\n            signer = getSignerFromOptions(provider, options, library);\n            contractWithSigner = connectContractToSigner(contract, options, signer);\n            opts = hasOpts ? args[args.length - 1] : undefined;\n            _context.next = 8;\n            return estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage);\n\n          case 8:\n            gasLimit = _context.sent;\n            modifiedOpts = Object.assign({\n              gasLimit: gasLimit\n            }, opts);\n            modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n            modifiedArgs.push(modifiedOpts);\n            _context.next = 14;\n            return promiseTransaction(contractWithSigner[functionName].apply(contractWithSigner, _toConsumableArray(modifiedArgs)));\n\n          case 14:\n            receipt = _context.sent;\n\n            if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n              _events = receipt.logs.reduce(function (accumulatedLogs, log) {\n                try {\n                  return log.address.toLowerCase() === contract.address.toLowerCase() ? [].concat(_toConsumableArray(accumulatedLogs), [contract.interface.parseLog(log)]) : accumulatedLogs;\n                } catch (_err) {\n                  return accumulatedLogs;\n                }\n              }, []);\n              setEvents(_events);\n            }\n\n            return _context.abrupt(\"return\", receipt);\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n  return {\n    send: send,\n    state: state,\n    events: events,\n    resetState: resetState\n  };\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractFunction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, librarySigner) {\n    if (contract.signer) {\n        return contract;\n    }\n    if (options && 'signer' in options) {\n        return contract.connect(options.signer);\n    }\n    if (librarySigner) {\n        return contract.connect(librarySigner);\n    }\n    throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction(contract, functionName, options) {\n    var _a, _b, _c;\n    const { library, chainId } = useEthers();\n    const transactionChainId = (options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId)) || chainId;\n    const { promiseTransaction, state, resetState } = usePromiseTransaction(transactionChainId, options);\n    const [events, setEvents] = useState(undefined);\n    const config = useConfig();\n    const gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n    const providers = useReadonlyNetworks();\n    const provider = (transactionChainId && providers[transactionChainId]);\n    const send = useCallback(async (...args) => {\n        var _a, _b;\n        if (contract) {\n            const hasOpts = args.length > ((_b = (_a = contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(functionName).inputs.length) !== null && _b !== void 0 ? _b : 0);\n            const signer = getSignerFromOptions(provider, options, library);\n            const contractWithSigner = connectContractToSigner(contract, options, signer);\n            const opts = hasOpts ? args[args.length - 1] : undefined;\n            const gasLimit = await estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage);\n            const modifiedOpts = Object.assign({ gasLimit }, opts);\n            const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n            modifiedArgs.push(modifiedOpts);\n            const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs));\n            if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n                const events = receipt.logs.reduce((accumulatedLogs, log) => {\n                    try {\n                        return log.address.toLowerCase() === contract.address.toLowerCase()\n                            ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                            : accumulatedLogs;\n                    }\n                    catch (_err) {\n                        return accumulatedLogs;\n                    }\n                }, []);\n                setEvents(events);\n            }\n            return receipt;\n        }\n    }, [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n    return { send, state, events, resetState };\n}\n//# sourceMappingURL=useContractFunction.js.map"]},"metadata":{},"sourceType":"module"}