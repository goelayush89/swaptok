{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mymac/Documents/GitHub/Cryptoapp/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n\n  var contract = call.contract,\n      method = call.method,\n      args = call.args;\n  console.warn(\"Invalid contract call: address=\".concat(contract.address, \" method=\").concat(method, \" args=\").concat(args));\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function encodeCallData(call, chainId) {\n  var queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  if (!call) {\n    return undefined;\n  }\n\n  var contract = call.contract,\n      method = call.method,\n      args = call.args;\n\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n\n  try {\n    var isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n    var refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args),\n      chainId: chainId,\n      isStatic: isStatic,\n      refreshPerBlocks: refreshPerBlocks\n    };\n  } catch (_b) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function getUniqueActiveCalls(requests) {\n  var unique = [];\n  var used = {};\n\n  var _iterator = _createForOfIteratorHelper(requests),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var request = _step.value;\n\n      if (!used[\"\".concat(request.address.toLowerCase()).concat(request.data).concat(request.chainId)]) {\n        unique.push(request);\n        used[\"\".concat(request.address.toLowerCase()).concat(request.data).concat(request.chainId)] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function getCallsForUpdate(requests, options) {\n  var callsForUpdate = [];\n\n  var _iterator2 = _createForOfIteratorHelper(requests),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var request = _step2.value;\n\n      if (options) {\n        if (options.chainId && options.chainId !== request.chainId) {\n          continue;\n        }\n\n        if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n          continue;\n        }\n\n        var currentBlock = options.blockNumber;\n\n        if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n          if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n            continue;\n          }\n        }\n      }\n\n      callsForUpdate.push(request);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function decodeCallResult(call, result) {\n  if (!result || !call) {\n    return undefined;\n  }\n\n  var value = result.value,\n      success = result.success;\n\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      var errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}","map":{"version":3,"sources":["../../../../src/helpers/calls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n    if (!call) {\n        return;\n    }\n    const { contract, method, args } = call;\n    console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function encodeCallData(call, chainId, queryParams = {}) {\n    var _a;\n    if (!call) {\n        return undefined;\n    }\n    const { contract, method, args } = call;\n    if (!contract.address || !method) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n    try {\n        const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n        const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n        return {\n            address: contract.address,\n            data: contract.interface.encodeFunctionData(method, args),\n            chainId,\n            isStatic,\n            refreshPerBlocks,\n        };\n    }\n    catch (_b) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n    const unique = [];\n    const used = {};\n    for (const request of requests) {\n        if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n            unique.push(request);\n            used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n        }\n    }\n    return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n    const callsForUpdate = [];\n    for (const request of requests) {\n        if (options) {\n            if (options.chainId && options.chainId !== request.chainId) {\n                continue;\n            }\n            if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n                continue;\n            }\n            const currentBlock = options.blockNumber;\n            if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n                if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n                    continue;\n                }\n            }\n        }\n        callsForUpdate.push(request);\n    }\n    return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n    if (!result || !call) {\n        return undefined;\n    }\n    const { value, success } = result;\n    try {\n        if (success) {\n            return {\n                value: call.contract.interface.decodeFunctionResult(call.method, value),\n                error: undefined,\n            };\n        }\n        else {\n            const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n            return {\n                value: undefined,\n                error: new Error(errorMessage),\n            };\n        }\n    }\n    catch (error) {\n        return {\n            value: undefined,\n            error: error,\n        };\n    }\n}\n//# sourceMappingURL=calls.js.map"]},"metadata":{},"sourceType":"module"}