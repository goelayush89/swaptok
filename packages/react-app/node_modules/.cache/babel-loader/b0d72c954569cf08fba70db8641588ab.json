{"ast":null,"code":"import _slicedToArray from \"/Users/mymac/Documents/GitHub/Cryptoapp/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nvar Provider = providers.Provider,\n    StaticJsonRpcProvider = providers.StaticJsonRpcProvider;\n\nvar getProviderFromConfig = function getProviderFromConfig(urlOrProviderOrProviderFunction) {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction;\n  }\n\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction();\n  }\n\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\n\nexport var getProvidersFromConfig = function getProvidersFromConfig(readOnlyUrls) {\n  return fromEntries(Object.entries(readOnlyUrls).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        chainId = _ref2[0],\n        urlOrProviderOrProviderFunction = _ref2[1];\n\n    return [chainId, getProviderFromConfig(urlOrProviderOrProviderFunction)];\n  }));\n};\nexport function ReadonlyNetworksProvider(_ref3) {\n  var _ref3$providerOverrid = _ref3.providerOverrides,\n      providerOverrides = _ref3$providerOverrid === void 0 ? {} : _ref3$providerOverrid,\n      children = _ref3.children;\n\n  var _useConfig = useConfig(),\n      _useConfig$readOnlyUr = _useConfig.readOnlyUrls,\n      readOnlyUrls = _useConfig$readOnlyUr === void 0 ? {} : _useConfig$readOnlyUr,\n      pollingInterval = _useConfig.pollingInterval,\n      pollingIntervals = _useConfig.pollingIntervals;\n\n  var _useWindow = useWindow(),\n      isActive = _useWindow.isActive;\n\n  var _useState = useState(function () {\n    return Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides);\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      providers = _useState2[0],\n      setProviders = _useState2[1];\n\n  var _useReducer = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map(function (chainId) {\n    return [chainId, {\n      nonStaticCalls: 0\n    }];\n  })))),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      networkStates = _useReducer2[0],\n      dispatchNetworkState = _useReducer2[1];\n\n  var getPollingInterval = useCallback(function (chainId) {\n    var _a;\n\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  useEffect(function () {\n    setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  }, Object.entries(readOnlyUrls).flat());\n  useEffect(function () {\n    for (var _i = 0, _Object$entries = Object.entries(networkStates); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          chainId = _Object$entries$_i[0],\n          nonStaticCalls = _Object$entries$_i[1].nonStaticCalls;\n\n      var provider = providers[chainId];\n\n      if (provider) {\n        provider.polling = isActive && nonStaticCalls > 0;\n      }\n    }\n  }, [networkStates, isActive]);\n  useEffect(function () {\n    for (var _i2 = 0, _Object$entries2 = Object.entries(providers); _i2 < _Object$entries2.length; _i2++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n          chainId = _Object$entries2$_i[0],\n          provider = _Object$entries2$_i[1];\n\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId));\n      }\n    }\n  }, [providers, getPollingInterval]);\n  var networks = useMemo(function () {\n    return {\n      providers: providers,\n      updateNetworkState: dispatchNetworkState\n    };\n  }, [providers, dispatchNetworkState]);\n  return _jsx(ReadonlyNetworksContext.Provider, Object.assign({\n    value: networks\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"sources":["../../../../../../src/providers/network/readonlyNetworks/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst { Provider, StaticJsonRpcProvider } = providers;\nconst getProviderFromConfig = (urlOrProviderOrProviderFunction) => {\n    if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n        return urlOrProviderOrProviderFunction;\n    }\n    if (typeof urlOrProviderOrProviderFunction === 'function') {\n        return urlOrProviderOrProviderFunction();\n    }\n    return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\nexport const getProvidersFromConfig = (readOnlyUrls) => fromEntries(Object.entries(readOnlyUrls).map(([chainId, urlOrProviderOrProviderFunction]) => [\n    chainId,\n    getProviderFromConfig(urlOrProviderOrProviderFunction),\n]));\nexport function ReadonlyNetworksProvider({ providerOverrides = {}, children }) {\n    const { readOnlyUrls = {}, pollingInterval, pollingIntervals } = useConfig();\n    const { isActive } = useWindow();\n    const [providers, setProviders] = useState(() => (Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides)));\n    const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map((chainId) => [chainId, { nonStaticCalls: 0 }]))));\n    const getPollingInterval = useCallback((chainId) => { var _a; return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval; }, [\n        pollingInterval,\n        pollingIntervals,\n    ]);\n    useEffect(() => {\n        setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n    }, Object.entries(readOnlyUrls).flat());\n    useEffect(() => {\n        for (const [chainId, { nonStaticCalls }] of Object.entries(networkStates)) {\n            const provider = providers[chainId];\n            if (provider) {\n                provider.polling = isActive && nonStaticCalls > 0;\n            }\n        }\n    }, [networkStates, isActive]);\n    useEffect(() => {\n        for (const [chainId, provider] of Object.entries(providers)) {\n            if (!isWebSocketProvider(provider)) {\n                provider.pollingInterval = getPollingInterval(Number(chainId));\n            }\n        }\n    }, [providers, getPollingInterval]);\n    const networks = useMemo(() => ({\n        providers,\n        updateNetworkState: dispatchNetworkState,\n    }), [providers, dispatchNetworkState]);\n    return _jsx(ReadonlyNetworksContext.Provider, Object.assign({ value: networks }, { children: children }));\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}