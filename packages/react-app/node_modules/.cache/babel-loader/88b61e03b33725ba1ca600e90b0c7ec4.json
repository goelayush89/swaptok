{"ast":null,"code":"import _slicedToArray from \"/Users/mymac/Documents/GitHub/Cryptoapp/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nimport { useWindow } from '../../window/context';\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context';\n\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(function (chainId) {\n    return [Number(chainId), {\n      value: state[Number(chainId)],\n      multicallAddress: multicallAddresses[Number(chainId)]\n    }];\n  }));\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nvar stripCall = function stripCall(_a) {\n  var isStatic = _a.isStatic,\n      lastUpdatedBlockNumber = _a.lastUpdatedBlockNumber,\n      strippedCall = __rest(_a, [\"isStatic\", \"lastUpdatedBlockNumber\"]);\n\n  return strippedCall;\n};\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nexport function MultiChainStateProvider(_ref) {\n  var children = _ref.children,\n      multicallAddresses = _ref.multicallAddresses;\n\n  var _useConfig = useConfig(),\n      multicallVersion = _useConfig.multicallVersion,\n      fastMulticallEncoding = _useConfig.fastMulticallEncoding;\n\n  var networks = useReadonlyNetworks();\n  var blockNumbers = useBlockNumbers();\n\n  var _useNetwork = useNetwork(),\n      reportError = _useNetwork.reportError;\n\n  var _useWindow = useWindow(),\n      isActive = _useWindow.isActive;\n\n  var _useReducer = useReducer(callsReducer, []),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      calls = _useReducer2[0],\n      dispatchCalls = _useReducer2[1];\n\n  var _useReducer3 = useReducer(chainStateReducer, {}),\n      _useReducer4 = _slicedToArray(_useReducer3, 2),\n      state = _useReducer4[0],\n      dispatchState = _useReducer4[1];\n\n  var updateNetworks = useUpdateNetworksState();\n  var multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n\n  var _useDebouncePair = useDebouncePair(calls, networks, 50),\n      _useDebouncePair2 = _slicedToArray(_useDebouncePair, 2),\n      debouncedCalls = _useDebouncePair2[0],\n      debouncedNetworks = _useDebouncePair2[1];\n\n  var uniqueCalls = useMemo(function () {\n    return getUniqueActiveCalls(debouncedCalls);\n  }, [debouncedCalls]); // used for deep equality in hook dependencies\n\n  var uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall));\n  var chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n\n  function multicallForChain(chainId, provider) {\n    if (!isActive) {\n      return;\n    }\n\n    var blockNumber = blockNumbers[chainId];\n    var multicallAddress = multicallAddresses[chainId];\n\n    if (!provider || !blockNumber) {\n      return;\n    }\n\n    if (!multicallAddress) {\n      reportError(new Error(\"Missing multicall address for chain id \".concat(chainId)));\n      return;\n    }\n\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n\n    var updatedCalls = getCallsForUpdate(debouncedCalls, {\n      chainId: chainId,\n      blockNumber: blockNumber\n    });\n    var callsOnThisChain = getUniqueActiveCalls(updatedCalls);\n    updateNetworks({\n      type: 'UPDATE_NON_STATIC_CALLS_COUNT',\n      chainId: chainId,\n      count: calls.filter(function (call) {\n        return !call.isStatic && call.chainId === chainId;\n      }).length\n    });\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n    dispatchCalls({\n      type: 'UPDATE_CALLS',\n      calls: calls,\n      updatedCalls: updatedCalls,\n      blockNumber: blockNumber,\n      chainId: chainId\n    });\n  }\n\n  useEffect(function () {\n    var _a, _b;\n\n    for (var _i = 0, _Object$entries = Object.entries(networks); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          _chainId = _Object$entries$_i[0],\n          provider = _Object$entries$_i[1];\n\n      var _chainId2 = Number(_chainId); // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n\n\n      if (_chainId2 === ((_a = provider.network) === null || _a === void 0 ? void 0 : _a.chainId) || _chainId2 === ((_b = provider._network) === null || _b === void 0 ? void 0 : _b.chainId)) {\n        multicallForChain(_chainId2, provider);\n      }\n    }\n  }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers]);\n  var chains = useMemo(function () {\n    return composeChainState(networks, state, multicallAddresses);\n  }, [state, multicallAddresses, networks]);\n  var provided = {\n    chains: chains,\n    dispatchCalls: dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../../src/providers/chainState/multiChainStates/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nimport { useWindow } from '../../window/context';\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context';\nfunction composeChainState(networks, state, multicallAddresses) {\n    return fromEntries(Object.keys(networks).map((chainId) => [\n        Number(chainId),\n        {\n            value: state[Number(chainId)],\n            multicallAddress: multicallAddresses[Number(chainId)],\n        },\n    ]));\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stripCall = (_a) => {\n    var { isStatic, lastUpdatedBlockNumber } = _a, strippedCall = __rest(_a, [\"isStatic\", \"lastUpdatedBlockNumber\"]);\n    return strippedCall;\n};\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({ children, multicallAddresses }) {\n    const { multicallVersion, fastMulticallEncoding } = useConfig();\n    const networks = useReadonlyNetworks();\n    const blockNumbers = useBlockNumbers();\n    const { reportError } = useNetwork();\n    const { isActive } = useWindow();\n    const [calls, dispatchCalls] = useReducer(callsReducer, []);\n    const [state, dispatchState] = useReducer(chainStateReducer, {});\n    const updateNetworks = useUpdateNetworksState();\n    const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n    const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n    const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls]);\n    // used for deep equality in hook dependencies\n    const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall));\n    const chainId = useChainId();\n    useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n    function multicallForChain(chainId, provider) {\n        if (!isActive) {\n            return;\n        }\n        const blockNumber = blockNumbers[chainId];\n        const multicallAddress = multicallAddresses[chainId];\n        if (!provider || !blockNumber) {\n            return;\n        }\n        if (!multicallAddress) {\n            reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n            return;\n        }\n        if (debouncedNetworks !== networks) {\n            // Wait for debounce to catch up.\n            return;\n        }\n        const updatedCalls = getCallsForUpdate(debouncedCalls, { chainId, blockNumber });\n        const callsOnThisChain = getUniqueActiveCalls(updatedCalls);\n        updateNetworks({\n            type: 'UPDATE_NON_STATIC_CALLS_COUNT',\n            chainId,\n            count: calls.filter((call) => !call.isStatic && call.chainId === chainId).length,\n        });\n        performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n        dispatchCalls({ type: 'UPDATE_CALLS', calls, updatedCalls, blockNumber, chainId });\n    }\n    useEffect(() => {\n        var _a, _b;\n        for (const [_chainId, provider] of Object.entries(networks)) {\n            const chainId = Number(_chainId);\n            // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n            if (chainId === ((_a = provider.network) === null || _a === void 0 ? void 0 : _a.chainId) || chainId === ((_b = provider._network) === null || _b === void 0 ? void 0 : _b.chainId)) {\n                multicallForChain(chainId, provider);\n            }\n        }\n    }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers]);\n    const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [\n        state,\n        multicallAddresses,\n        networks,\n    ]);\n    const provided = { chains, dispatchCalls };\n    return _jsx(MultiChainStatesContext.Provider, { value: provided, children: children });\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}